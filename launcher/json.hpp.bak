#pragma once

#include <string>
#include <vector>
#include <map>
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <variant>
#include <iostream>
#include <cstdint> // 修复 int64_t 未定义
#include <type_traits> // 新增，用于 remove_reference_t

namespace nlohmann {

    class json {
    public:
        enum class value_t { object, array, string, number_integer, number_float, boolean, null };

        using object_t = std::map<std::string, json>;
        using array_t = std::vector<json>;
        using string_t = std::string;
        using number_integer_t = int64_t;
        using number_float_t = double;
        using boolean_t = bool;

        json() : m_type(value_t::null), m_value(nullptr) {}
        json(std::nullptr_t) : m_type(value_t::null), m_value(nullptr) {}
        json(const std::string& s) : m_type(value_t::string), m_value(string_t(s)) {}
        json(const char* s) : m_type(value_t::string), m_value(string_t(s)) {}
        json(int i) : m_type(value_t::number_integer), m_value(static_cast<number_integer_t>(i)) {}
        json(double d) : m_type(value_t::number_float), m_value(d) {}
        json(bool b) : m_type(value_t::boolean), m_value(b) {}
        json(const array_t& a) : m_type(value_t::array), m_value(a) {}
        json(const object_t& o) : m_type(value_t::object), m_value(o) {}

        static json parse(std::istream& is) {
            // This is a dummy and very incomplete parser
            char c;
            is >> c;
            if (c == '{') {
                json j = object_t();
                while (is >> c && c != '}') {
                    if (c == '"') {
                        std::string key;
                        std::getline(is, key, '"');
                        is >> c; // colon
                        j[key] = json::parse(is);
                    }
                }
                return j;
            }
            if (c == '[') {
                json j = array_t();
                while(is >> c && c != ']') {
                    is.putback(c);
                    // 直接访问内部 variant，避免在 parse() 中提前使用依赖返回类型的模板
                    std::get<array_t>(j.m_value).push_back(json::parse(is));
                }
                return j;
            }
            if (c == '"') {
                std::string s;
                std::getline(is, s, '"');
                return json(s);
            }
            return json();
        }

        static json parse(const std::string& s) {
            std::stringstream ss(s);
            return parse(ss);
        }

        std::string dump(int indent = -1) const {
            std::stringstream ss;
            if (m_type == value_t::object) {
                ss << "{";
                bool first = true;
                for (const auto& pair : std::get<object_t>(m_value)) {
                    if (!first) ss << ",";
                    first = false;
                    ss << "\"" << pair.first << "\":" << pair.second.dump();
                }
                ss << "}";
            } else if (m_type == value_t::array) {
                ss << "[";
                bool first = true;
                for (const auto& item : std::get<array_t>(m_value)) {
                    if (!first) ss << ",";
                    first = false;
                    ss << item.dump();
                }
                ss << "]";
            } else if (m_type == value_t::string) {
                ss << "\"" << std::get<string_t>(m_value) << "\"";
            } else if (m_type == value_t::number_integer) {
                ss << std::get<number_integer_t>(m_value);
            }
            return ss.str();
        }

        bool is_object() const { return m_type == value_t::object; }
        bool is_array() const { return m_type == value_t::array; }
        bool is_string() const { return m_type == value_t::string; }
        bool is_number_integer() const { return m_type == value_t::number_integer; }
        bool is_number_float() const { return m_type == value_t::number_float; }
        bool is_boolean() const { return m_type == value_t::boolean; }
        bool is_null() const { return m_type == value_t::null; }

        bool contains(const std::string& key) const {
            if (!is_object()) return false;
            const auto& obj = std::get<object_t>(m_value);
            return obj.find(key) != obj.end();
        }
        
        template<typename T> T get() const;
        // 通用 get_ref 实现：接受 T 或 T&（支持传入带 & 的类型参数）
        template<typename T>
        auto& get_ref() {
            using U = std::remove_reference_t<T>;
            return std::get<U>(m_value);
        }
        template<typename T>
        const auto& get_ref() const {
            using U = std::remove_reference_t<T>;
            return std::get<U>(m_value);
        }

        json& operator[](const std::string& key) {
            if (m_type != value_t::object) {
                m_type = value_t::object;
                m_value = object_t();
            }
            return std::get<object_t>(m_value)[key];
        }
        
        auto begin() { return std::get<array_t>(m_value).begin(); }
        auto end() { return std::get<array_t>(m_value).end(); }
        auto begin() const { return std::get<array_t>(m_value).begin(); }
        auto end() const { return std::get<array_t>(m_value).end(); }
        auto items() { return std::get<object_t>(m_value); }

    private:
        value_t m_type;
        std::variant<std::nullptr_t, boolean_t, number_integer_t, number_float_t, string_t, array_t, object_t> m_value;
    };

    // 模板特化实现
    // 移除了在文件尾部导致 “specialization after instantiation” 的显式特化
    template<> inline std::string json::get<std::string>() const { return std::get<string_t>(m_value); }

} // namespace nlohmann