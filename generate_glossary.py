#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
根据VTT字幕文件自动生成术语表
"""

import webvtt
import logging
from pathlib import Path
from typing import List, Dict
import collections
from tqdm import tqdm

# 假设 VTTCorrector 类定义在 process_subtitle 中
from process_subtitle import VTTCorrector, _report_progress

logger = logging.getLogger(__name__)

class GlossaryGenerator:
    def __init__(self, corrector: VTTCorrector):
        """
        初始化术语表生成器
        
        Args:
            corrector: 一个 VTTCorrector 实例，用于访问LLM
        """
        if not corrector or not corrector.model:
            raise ValueError("必须提供一个已成功加载模型的 VTTCorrector 实例。")
        self.corrector = corrector
        self.dic_counter = collections.Counter()
        self.dic_list = []

    def _create_glossary_prompt(self, text_chunk: str) -> (str, str):
        """
        创建用于生成术语表的提示词
        """
        templates = self.corrector.model_config.get("prompt_templates", {})
        system_prompt = templates.get(
            "glossary_system_prompt", 
            "你是一名专家级翻译员，擅长从文本中提取专有名词并构建术语表。"
        )
        prompt_template = templates.get(
            "glossary_prompt",
            "## 任务\n从输入的文本片段中构建用于日译中的术语表，主要包括独特的专有名词（人名、地名、特殊物品、技能等）。\n\n## 输出要求\n- 使用TSV格式，包含三列：日文原词, 中文翻译, 备注。\n- 如果没有专有名词，输出一行 `NULL\tNULL\tNULL`。\n- 直接停止输出，不要添加任何解释。\n\n## 输入\n{input}\n\n## 输出\n```tsv\n日文原词\t中文翻译\t备注\n"
        )
        
        # GenDic.py中的hint逻辑简化为“无”
        prompt = prompt_template.format(input=text_chunk, hint="无")
        return prompt, system_prompt

    def _parse_llm_response(self, response: str):
        """
        解析LLM返回的TSV格式的术语表
        """
        lines = response.strip().split('\n')
        for line in lines:
            # 移除可能的代码块标记
            if line.strip().startswith("`"):
                continue
            if "日文原词" in line or "中文翻译" in line:
                continue

            parts = line.split('\t')
            if len(parts) < 3:
                continue
            
            src, dst, note = parts[0].strip(), parts[1].strip(), parts[2].strip()

            if "NULL" in src or not src:
                continue

            # 使用 (src, dst, note) 作为键来避免完全相同的条目重复
            entry = (src, dst, note)
            if entry not in self.dic_counter:
                self.dic_list.append(list(entry))
            self.dic_counter[entry] += 1


    def generate_from_vtt(self, vtt_file_path: str) -> bool:
        """
        从VTT文件生成术语表，并将其保存在 .\cache\subtitles\glossary\ 目录下
        """
        try:
            logger.info(f"开始从 {vtt_file_path} 生成术语表...")
            vtt = webvtt.read(vtt_file_path)
            
            # 1. 文本分块
            groups = self.corrector._group_captions(vtt.captions)
            
            # 2. 调用LLM处理每个文本块
            logger.info(f"将字幕分为 {len(groups)} 组进行处理...")
            total_groups = len(groups)
            for i, group in enumerate(tqdm(groups, desc="生成术语表")):
                text_segments = [caption.text.strip() for caption in group]
                text_chunk = "\n".join(text_segments)
                
                if not text_chunk:
                    continue

                prompt, system_prompt = self._create_glossary_prompt(text_chunk)
                response = self.corrector.execute_raw_prompt(prompt, system_prompt=system_prompt)
                self._parse_llm_response(response)
                
                # Report progress after processing each group
                _report_progress("术语表", i + 1, total_groups)

            # 3. 后处理
            final_list = []
            for item in self.dic_list:
                src, dst, note = item
                entry = (src, dst, note)
                is_key_term = any(k in note for k in ["人名", "地名", "组织", "技能"])
                if self.dic_counter[entry] > 1 or is_key_term:
                    final_list.append(item)
            
            final_list.sort(key=lambda x: self.dic_counter[(x[0], x[1], x[2])], reverse=True)

            # 4. 定义并创建输出目录
            output_dir = Path("./cache/subtitles/glossary")
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 5. 定义输出文件路径
            vtt_path_obj = Path(vtt_file_path)
            output_file_path = output_dir / f"{vtt_path_obj.stem}.txt"

            # 6. 写入文件
            with open(output_file_path, "w", encoding="utf-8") as f:
                f.write("# VTT-Auto-Glossary: Generated by LLM\n")
                f.write("# 格式: 日文原词\t中文翻译\t备注\n")
                for item in final_list:
                    f.write(f"{item[0]}\t{item[1]}\t{item[2]}\n")
            
            logger.info(f"术语表生成完成，共 {len(final_list)} 个词条，已保存至: {output_file_path}")
            return True

        except Exception as e:
            logger.error(f"生成术语表时发生错误: {e}", exc_info=True)
            return False
